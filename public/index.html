<!DOCTYPE html>
<html lang="en">
    <head>
        <title></title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="style.css" rel="stylesheet">
        <link href="grayscale.css" rel="stylesheet">
        <link href="interface.css" rel="stylesheet" media="screen">
        <script src="https://unpkg.com/pagedjs/dist/paged.polyfill.js"></script>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Crimson+Pro:ital,wght@0,400;0,600;0,800;1,400;1,600;1,800&family=Roboto+Condensed:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    </head>
    <body>
        
        <div class="chapter-cover">
            <div class="chapter-name">
                <h1 class="no-break">Function as useEffect's dependency</h1>
                <div class="no-break"><i>Tác giả:</i> huytd</div>
                <div class="no-break"><i>Chủ đề:</i> Front End, React</div>
            </div>
            <div class="chapter-number">
                <h3 class="no-break">Ngày thứ</h3>
                <h1 class="no-break">1</h1>
            </div>
        </div>
         <p>Khi sử dụng ESLint trong một dự án React, kiểu gì bạn cũng sẽ gặp tình huống mà bạn cho là vớ vẩn như sau: Bạn có một đoạn code xài useEffect, trong đó bạn gọi một function, thường thì function này được tạo ra ngay trong component hiện tại luôn, ví dụ:</p>
<pre><code>const doSomething = (someValue) =&gt; {
    // ...do something with someValue...
}

useEffect(() =&gt; {
   if (someValue) {
      doSomething(someValue)
   }
}, [someValue])
</code></pre>
<p>Và bạn sẽ bị ESLint quăng ngay một câu complain vô mặt:</p>
<blockquote>
<p>React Hook useEffect has a missing dependency: ‘doSomething’. Either include it or remove the dependency array</p>
</blockquote>
<p>Đây là warning từ plugin <code>eslint-plugin-react-hooks</code>, đại ý của nó là: “Ê sao mày xài hàm doSomething trong useEffect, mà không cho doSomething vào danh sách dependencies?”</p>
<p>“Tào lao hết sức!” – bạn nghĩ. Nó là một cái hàm chứ có phải value quái gì đâu mà phải bỏ vô dependency list???</p>
<p>Vậy đây có phải là bug của <code>eslint-plugin-react-hooks</code> không? Đáng ra chỉ nên áp dụng rule này lên các giá trị thông thường thôi, sao còn áp dụng với cả function?</p>
<p>Lý do là: Function cũng là các object, và trong React (functional component), chúng cũng được khởi tạo lại sau mỗi lần render giống như mọi object khác. Vậy nên, dù function của bạn không đổi, thì trên thực tế sau mỗi lần render, chúng ta đều có một instance mới của cái function đó được tạo ra.Để ví dụ rõ hơn, có thể xem qua trường hợp chúng ta dùng giá trị của một state ở trong function:</p>
<pre><code>const [name, setName] = useState(&quot;&quot;)

const sayHello = () =&gt; {
   console.log(`Hello, ${name}`)
}

useEffect(() =&gt; {
   sayHello()
}, [name])
</code></pre>
<p>Ở ví dụ trên, vì name là một state value, nó có thể thay đổi bất cứ lúc nào và khiến cho component bị re-render. Hàm sayHello sử dụng giá trị của name, nên đương nhiên nó là một đối tượng có khả năng thay đổi giống như state. Chính vì thế mà các function cũng được đưa vào diện cần đưa vào dependency list của useEffect.</p>
<p>Rồi, đã hiểu vấn đề, vậy khi gặp tình huống này thì làm sao để fix? Có nhiều cách để giải quyết vấn đề này, tuỳ theo implementation của function cần xử lý.</p>
<p>Nếu function không sử dụng value hay state nào của component hiện tại thì có thể move nó ra khỏi component:</p>
<pre><code>const sayHello = (name: string) =&gt; {
   console.log(&quot;Hello&quot;)
}

const Component = () =&gt; {
   const [name, setName] = useState(&quot;&quot;)

   useEffect(() =&gt; {
      sayHello(name)
   }, [name])
}
</code></pre>
<p>Nếu function có sử dụng value hay state thuộc component hiện tại, thì có thể define function này bên trong khối useEffect:</p>
<pre><code>const Component = () =&gt; {
   const [name, setName] = useState(&quot;&quot;)
   const [age, setAge] = useState(&quot;&quot;)

   useEffect(() =&gt; {
      const sayHello = () =&gt; {
         console.log(`I am ${name}, I am ${age} yo`)
      }

      sayHello()
   }, [name, age])
}
</code></pre>
<p>Lưu ý là, bạn phải đưa luôn toàn bộ những state mà function đó sử dụng vào dependency list luôn (vì function của bạn phụ thuộc vào những state đó).</p>
<p>Một cách khác là sử dụng useCallback hook để memoize function này sau mỗi lần render, tuỳ thuộc vào giá trị của các state mà function này sử dụng:</p>
<pre><code>const Component = () =&gt; {
   const sayHello = useCallback(() =&gt; {
      ...
   }, [/* danh sách state mà function cần */])

   useEffect(() =&gt; {
      if (age &gt; 0) {
          sayHello()
      }
   }, [age, sayHello])
}
</code></pre>
<p>Xài cách này, bạn vẫn phải đưa function này vào danh sách dependency như cách trước, nhưng có sự phân chia trong danh sách dependency rõ ràng hơn.</p>
 
        <div class="chapter-cover">
            <div class="chapter-name">
                <h1 class="no-break">You can’t simply send a UDP packet in web browser</h1>
                <div class="no-break"><i>Tác giả:</i> giongto35</div>
                <div class="no-break"><i>Chủ đề:</i> Front End, Networking</div>
            </div>
            <div class="chapter-number">
                <h3 class="no-break">Ngày thứ</h3>
                <h1 class="no-break">2</h1>
            </div>
        </div>
         <p>Thường trong khi đi học về network, chúng ta thường gặp câu hỏi là: trong các trường hợp mình đòi hỏi độ trễ thấp và không quan tâm packet sẽ bị rơi rớt giữa chừng, như video stream hoặc multiplayer game, thì network protocol nào nên sử dụng? Câu trả lời ai cũng có trong đầu là sử dụng UDP.</p>
<p>Tuy nhiên, một điều đáng ngạc nhiên (ít nhất đối với mình) là không có cách thuận tiện nào để gửi một gói tin UDP trên WebBrowser. WebSocket chỉ hỗ trợ giao thức TCP.</p>
<p>Bài viết sẽ trả lời tại sao và chúng ta làm thế nào để sử dụng UDP network protocol trên Browser.</p>
<p>&nbsp;</p>
<h2 id="udp-vs-tcp">UDP vs TCP.</h2>
<p>UDP và TCP là khái niệm cơ bản và ai cũng đã từng đọc qua nên mình chỉ nhắc lại nhanh chóng.</p>
<p>UDP (Unreliable Data Protocol):</p>
<ul>
<li>UDP là connectionless, nghĩa là mình không tạo connection mà gửi packet đi luôn. UDP không cần các cơ chế như Handshake, Flow Control…</li>
</ul>
<p>TCP (Transmission Control Protocol):</p>
<ul>
<li>TCP đảm bảo data được gửi đi theo đúng thứ tự và reliable. TCP có các cơ chế như three-way handshake, flow control, connection termination để gửi packet một cách secure và duy trì smooth connection.</li>
<li>Head-of-line blocking. Đây là vấn đề lớn nhất của TCP. Nếu một gói tin bị thất lạc, các gói tin tiếp theo sẽ đợi cho đến khi gói tin bị mất được gửi đi, ảnh hưởng đến throughput và latency.</li>
</ul>
<h2 id="nền-tảng-của-web-browser-được-xây-dựng-trên-http">Nền tảng của web browser được xây dựng trên HTTP</h2>
<p>HTTP/HTTPS là protocol chủ yếu để thực hiện request và response giữa browser và server. HTTP và HTTPS thường sử dụng port 80 và port 443. Vì là nền tảng mặc định, các ports này thường được Firewall cho phép outbound traffic.</p>
<h2 id="websocket-được-xây-dựng-trên-httptcp">WebSocket được xây dựng trên HTTP/TCP.</h2>
<p>WebSocket thường được dùng để tạo connection 2 chiều giữa client và server với low latency. WebSocket connection được tạo ra bằng bắt đầu bằng HTTP handshake và sau đó được upgrade lên Websocket protocol, tạo ra một full-duplex connection. Bằng cách dựa trên HTTP và các port mặc định của HTTP, WebSocket không yêu cầu mở thêm port cho connection và dễ dàng chấp thuận bởi Firewall. Tuy nhiên, cũng vì dựa trên HTTP, ta cũng phải sử dụng TCP cho Websocket.</p>
<h2 id="vì-sao-udp-không-được-hỗ-trợ-sẵn-trong-các-trình-duyệt">Vì sao UDP không được hỗ trợ sẵn trong các trình duyệt?</h2>
<p>UDP là connectionless và thiếu một số tính năng security có sẵn trong HTTPS (TLS). Vì không có connection nên packet nào nhìn cũng như nhau và 3rd party có thể chen vào giữa gửi packet, tạo ra rủi ro “Man In The Middle Attack”. Không có SSL nghĩa là gói tin không được mã hóa. Gói tin có thể bị giả danh hay sửa đổi trong quá trình gửi. UDP cũng không có flow control và congestion control như TCP. Điều này nghĩa là chúng ta không thể kiểm soát được lưu lượng UDP và dễ dẫn đến rủi ro DDoS từ trình duyệt web. Vì vậy, muốn sử dụng UDP trên WebBrowser, chúng ta cần thêm các layer phía trên hỗ trợ gửi UDP một cách an toàn.</p>
<h2 id="ân-nhân-webrtc">Ân nhân WebRTC</h2>
<p>WebRTC là một all-in-one protocol tổng hợp các protocol cho tầng transport, network, Video, NAT traverse, và hỗ trợ gửi UDP packet với mục đích then chốt để đạt được real-time p2p communication. Đầu tiên, nó được phát triển để cho ứng dụng Video Call nhưng sau đó hỗ trợ thêm Datagram cho phép gửi đi reliable hoặc unreliable packet.</p>
<p>Cách tiếp cận này cho phép WebRTC có thể gửi và nhận, stream video với độ trễ cực thấp. Khác với các giao thức dựa trên HTTP trên các port 80 và 443, WebRTC cho phép thiết lập peer-to-peer connection giữa bất kỳ thiết bị nào. Thông thường, các kết nối inbound và outbound cần được firewall, router thông qua, và khi di chuyển giữa các hop trong network, địa chỉ ip cũng thay đổi. WebRTC đạt được quyền năng thông qua một cơ chế rất phức tạp gọi là ICE để thực hiện NAT Traverse (vượt tường lửa). Cơ chế này giúp thiết bị tìm public ip và public address mà giữa 2 thiết bị có thể lập connection được. Nói về cơ chế này sẽ còn rất nhiều nhưng ngoài nội dung của bài viết.</p>
<p><img src="img/webrtc.png" alt=""></p>
<p>Sau khi connection được thiết lập giữa 2 device, WebRTC sẽ cho phép bạn stream media hay gửi UDP datagram thông qua connection này. WebRTC sử dụng DTLS (Datagram TLS) nên UDP datagram dựa trên WebRTC cũng được đảm bảo security.</p>
<h2 id="nhưng-rồi-webrtc-trở-nên-quá-phức-tạp-cho-mô-hình-client-server">Nhưng rồi WebRTC trở nên quá phức tạp cho mô hình client-server.</h2>
<p>WebRTC rất ràng buộc về các protocol được phép sử dụng. SCTP, DTLS, RTP, SRTP, ICE và Video Codec (VP8, H264, OPUS). Mỗi cái term này lại là một vùng trời kiến thức đòi hỏi người sử dụng nắm bắt. Vì WebRTC, được thiết kế ban đầu cho Video Call và giao tiếp peer-to-peer, các tính năng liên quan đến NAT Traversal không cần thiết trong mô hình client-server. Về phía server, mình có toàn quyền quyết định network và port setting, không cần WebRTC làm hộ. Khởi tạo connection cũng là một chiều outbound từ client đến server chứ không phải là 2 chiều.</p>
<p>Ngoài ra, bạn cũng không có nhiều khả năng thay đổi cách bạn muốn gửi packet nếu muốn sửa congestion/flow control. WebRTC là một cái blackbox mà nếu nó work thì work và không work thì bạn cũng không biết cách nào khác để làm nó tốt hơn.</p>
<p>WebRTC hiện tại vẫn là cách phổ biến nhất để gửi UDP trong client-server architecture cho các ứng dụng yêu cầu độ trễ thấp như Video Stream, Cloud Gaming, Online Game; dù cho WebRTC hoàn toàn bắt đầu từ một nhu cầu khác. Yêu cầu gửi UDP packet tưởng chừng nghe cơ bản và nền tảng này đang lại trở thành một trở ngại lớn khi phát triển các sản phẩm đòi hỏi low latency ngày nay.</p>
<h2 id="vậy-tương-lai-của-udp-là">Vậy tương lai của UDP là?</h2>
<p>Có một số tiến triển đáng kể để việc sử dụng UDP trên WebBrowser ngày càng khả thi hơn. Chúng ta sẽ dành dịp khác để nói tiếp về nó.</p>
<ul>
<li>WebTransport: Hỗ trợ HTTP/3, giúp có thể thiết lập reliable hoặc unreliable transport. (<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebTransport">https://developer.mozilla.org/en-US/docs/Web/API/WebTransport</a>)</li>
<li>WHIP/WHEP: WebRTC dựa trên HTTP. (<a href="https://www.ietf.org/archive/id/draft-ietf-wish-whip-01.html">https://www.ietf.org/archive/id/draft-ietf-wish-whip-01.html</a>)</li>
</ul>
<h2 id="tham-khảo-thêm">Tham khảo thêm</h2>
<ul>
<li>Agar.IO creator phàn nàn về WebSocket không có UDP và WebRTC quá phức tạp. (<a href="https://news.ycombinator.com/item?id=13264952">https://news.ycombinator.com/item?id=13264952</a>)</li>
</ul>
 
        <div class="chapter-cover">
            <div class="chapter-name">
                <h1 class="no-break">Tiny trees, in tiny pots 🌲</h1>
                <div class="no-break"><i>Tác giả:</i> Bần làm vườn</div>
                <div class="no-break"><i>Chủ đề:</i> Hobby, Plant</div>
            </div>
            <div class="chapter-number">
                <h3 class="no-break">Ngày thứ</h3>
                <h1 class="no-break">3</h1>
            </div>
        </div>
         <p>Bonsai. I’m talking about bonsai. Lúc bắt đầu viết thì mình cũng hơi đắn đo không biết là bản thân có đủ qualified để viết về chủ đề này hay không. Nhưng suy cho cùng mục đích của mình ở đây không phải viết một cái comprehensive guide, để khi đọc xong mọi người trở thành bonsai expert. Sharing này mong có thể giúp các bạn hiểu hơn về bonsai, và inspire các bạn thử sức với hobby này.</p>
<h2 id="what-is-bonsai">What is bonsai?</h2>
<p>Bonsai là một từ tiếng Nhật. Và cũng như rất nhiều kỹ nghệ khác được người Nhật hoàn hảo hóa và nâng lên tầm cao mới, thì concept về bonsai vốn có xuất xứ từ… Trung Hoa cổ đại. Thời ấy họ rất xem trọng những vấn đề về phong thủy và cân bằng ngũ hành (chủ đề này thì thú thật mình mù). Một chậu Bonsai đóng vai trò như một mảng núi, mảng rừng thu nhỏ trong nhà, để đảm bảo sự cân bằng ngũ hành đó (mình đoán là mang tính kim và tính mộc or something). Sau hơn 3000 năm thì người ta vẫn thích bonsai, không hoàn toàn vì lý do phong thủy ban đầu nữa, mà chỉ đơn thuần như một cách để họ gần gũi với thiên nhiên hơn.Ok. Nếu vậy thì bonsai khác gì những cây trồng chậu khác? Một quyển sách về bonsai viết rằng, bonsai có hai tuổi. Tuổi thứ nhất là tuổi vật lý, sinh lý của nó. Tuổi thứ hai là tuổi nó đang mong muốn đóng giả. Bonsai không phải là một giống cây đặc biệt, có kích cỡ nhỏ bé ngay cả khi chúng già đi và phát triển tối đa. Bonsai là một cây trưởng thành, được cẩn thận uốn nén, cắt tỉa để giữ được tầm vóc thiếu nhi, nhưng mang dáng hình của một bô lão. Sẽ có một số style và loại cây được cho là phù hợp với tinh thần bonsai “truyền thống” hơn. Nhưng ở mức độ cơ bản, bất cứ loại cây nào cũng có thể trở thành bonsai nếu phù hợp với điều kiện trên.
Bonsai is as cheap and interesting as you want it to be</p>
<p>Mặc dù làm vườn được một thời gian nhưng mãi đến gần đây mình vẫn còn có ác cảm với bonsai. Bởi trong tiềm thức của mình, bonsai là một thú chơi đắt tiền và mang tính phù phiếm. Ngộ nhận này đến từ việc trước đây khi nghe người ta nói về bonsai, điều mà nhiều người quan tâm đến đầu tiên là giá trị vật chất. Nhà nào có nhiều bonsai thì nhà ấy chắc hẳn là giàu. Nhiều người sưu tầm bonsai cũng chỉ xem nó như một món hàng hóa xa xỉ, giá trị cao. Thực tế đó là đúng. Có một thực tế khác cũng đúng là có được một cây bonsai đẹp rất khó, phải trả qua rất nhiều năm, và vì vậy giá trị cao của nó là có căn cứ.Tuy nhiên điểm mấu chốt ở đây là, bonsai không chỉ là thú chơi sở hữu. Với mình nó là một quá trình, và quá trình đó có một cái barrier of entry rất thấp, bắt nguồn từ ý mình đã nêu ở trên: bất cứ cây gì cũng có khả năng trở thành bonsai. Và khi tự mình không đặt nặng vấn đề làm bonsai thế nào để hợp thị hiếu và cho được giá, thì khi tham gia cuộc chơi mình sẽ có tinh thần thoải mái và được giải phóng khỏi những ràng buộc khuôn khổ. Mọi người có thể search từ khóa bonchi (bonsai chili) để minh chứng cho việc cây nào cũng có thể làm bonsai được (yes, ngay cả 🍁).</p>
<h2 id="how-to-start-making-a-bonsai">How to start making a bonsai?</h2>
<p>Khi làm bonsai người ta sẽ xuất phát từ hai hướng. Một là họ sẽ trồng từ cây con, bắt đầu uốn nắn nó ngay từ nhỏ. Hai là họ sẽ tìm một gốc cây đẹp, trong tự nhiên, hoặc là mua hay xin lại từ ai đó, và họ sẽ tạo dáng lại phần nhánh. Phương án một rất dễ và rất tiết kiệm để bắt đầu, và mình cũng recommend mọi người đi theo hướng đó. Tất nhiên là nó sẽ mất nhiều thời gian hơn, but hey, it’s part of the journey.:spiral_note_pad: Mình gửi ở đây list một vài loài cây thường được dùng làm bonsai và phù hợp với khí hậu VN:</p>
<p>…</p>
 
    </body>
</html>
